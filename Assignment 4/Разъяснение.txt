Просто очередное напоминание, что нельзя сравнивать два double напрямую.
Как я понял, что там происходит (в цикле for в main() есть комментарий, 
объясняющий алгоритм получения эффекта) - при компиляции, в зависимости от наличия указанной строчки,
по-разному организуется память программы, и, вероятно, при конвертации значения 0.01 (в Ball.h ball::dt по умолчанию),
или любого другого в коде в double, двоичная ошибка (от преобразования из десятичной в двоичную) выходит разная из-за
каких-то особенностей работы компилятора. Было бы, конечно, интересно узнать, что конкретно ломается, но я, наверное, просто
впишу в реализацию ball::fly() учёт погрешности конвертации (в первом if).
update: Оссознал, что, вероятно, погрешность кроется в рассчетах ball::collision_alarm, так как он выдаёт
dt+1 (что заведомо больше dt, и коллизии не происходит), если оба корня уравнения меньше нуля, и корень уравнения, если иначе.
Так что, видимо, именно при подсчёте корня t1, который "внутри" стены должен быть ноль, происходит скачок туда-сюда.
