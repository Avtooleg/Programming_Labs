Просто очередное напоминание, что нельзя сравнивать два double напрямую.
Как я понял, что там происходит (в цикле for в main() есть комментарий, 
объясняющий алгоритм получения эффекта) - при компиляции, в зависимости от наличия указанной строчки,
по-разному организуется память программы, и, вероятно, при конвертации значения 0.01 (в Ball.h ball::dt по умолчанию),
или любого другого в коде в double, двоичная ошибка (от преобразования из десятичной в двоичную) выходит разная из-за
каких-то особенностей работы компилятора. Было бы, конечно, интересно узнать, что конкретно ломается, но я, наверное, просто
впишу в реализацию ball::fly() учёт погрешности конвертации (в первом if).